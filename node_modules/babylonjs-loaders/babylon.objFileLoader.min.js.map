{"version":3,"file":"babylon.objFileLoader.min.js","mappings":"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","sources":["webpack://LOADERS/webpack/universalModuleDefinition","webpack://LOADERS/external umd {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://LOADERS/webpack/bootstrap","webpack://LOADERS/webpack/runtime/define property getters","webpack://LOADERS/webpack/runtime/global","webpack://LOADERS/webpack/runtime/hasOwnProperty shorthand","webpack://LOADERS/webpack/runtime/make namespace object","webpack://LOADERS/../../../dev/loaders/src/OBJ/mtlFileLoader.ts","webpack://LOADERS/../../../dev/loaders/src/OBJ/solidParser.ts","webpack://LOADERS/../../../dev/loaders/src/OBJ/objFileLoader.ts","webpack://LOADERS/../../../dev/loaders/src/OBJ/objFileLoader.metadata.ts","webpack://LOADERS/../../../lts/loaders/src/legacy/legacy-objFileLoader.ts","webpack://LOADERS/./src/objFileLoader.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-loaders\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-loaders\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"LOADERS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), (__WEBPACK_EXTERNAL_MODULE__597__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__597__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n/**\r\n * Class reading and parsing the MTL file bundled with the obj file.\r\n */\r\nexport class MTLFileLoader {\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static INVERT_TEXTURE_Y = true;\r\n\r\n    /**\r\n     * All material loaded from the mtl will be set here\r\n     */\r\n    public materials: StandardMaterial[] = [];\r\n\r\n    /**\r\n     * This function will read the mtl file and create each material described inside\r\n     * This function could be improve by adding :\r\n     * -some component missing (Ni, Tf...)\r\n     * -including the specific options available\r\n     *\r\n     * @param scene defines the scene the material will be created in\r\n     * @param data defines the mtl data to parse\r\n     * @param rootUrl defines the rooturl to use in order to load relative dependencies\r\n     * @param assetContainer defines the asset container to store the material in (can be null)\r\n     */\r\n    public parseMTL(scene: Scene, data: string | ArrayBuffer, rootUrl: string, assetContainer: Nullable<AssetContainer>): void {\r\n        if (data instanceof ArrayBuffer) {\r\n            return;\r\n        }\r\n\r\n        //Split the lines from the file\r\n        const lines = data.split(\"\\n\");\r\n        // whitespace char ie: [ \\t\\r\\n\\f]\r\n        const delimiter_pattern = /\\s+/;\r\n        //Array with RGB colors\r\n        let color: number[];\r\n        //New material\r\n        let material: Nullable<StandardMaterial> = null;\r\n\r\n        //Look at each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i].trim();\r\n\r\n            // Blank line or comment\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            }\r\n\r\n            //Get the first parameter (keyword)\r\n            const pos = line.indexOf(\" \");\r\n            let key = pos >= 0 ? line.substring(0, pos) : line;\r\n            key = key.toLowerCase();\r\n\r\n            //Get the data following the key\r\n            const value: string = pos >= 0 ? line.substring(pos + 1).trim() : \"\";\r\n\r\n            //This mtl keyword will create the new material\r\n            if (key === \"newmtl\") {\r\n                //Check if it is the first material.\r\n                // Materials specifications are described after this keyword.\r\n                if (material) {\r\n                    //Add the previous material in the material array.\r\n                    this.materials.push(material);\r\n                }\r\n                //Create a new material.\r\n                // value is the name of the material read in the mtl file\r\n\r\n                scene._blockEntityCollection = !!assetContainer;\r\n                material = new StandardMaterial(value, scene);\r\n                material._parentContainer = assetContainer;\r\n                scene._blockEntityCollection = false;\r\n            } else if (key === \"kd\" && material) {\r\n                // Diffuse color (color under white light) using RGB values\r\n\r\n                //value  = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.diffuseColor = Color3.FromArray(color);\r\n            } else if (key === \"ka\" && material) {\r\n                // Ambient color (color under shadow) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.ambientColor = Color3.FromArray(color);\r\n            } else if (key === \"ks\" && material) {\r\n                // Specular color (color when light is reflected from shiny surface) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set the color into the material\r\n                material.specularColor = Color3.FromArray(color);\r\n            } else if (key === \"ke\" && material) {\r\n                // Emissive color using RGB values\r\n                color = value.split(delimiter_pattern, 3).map(parseFloat);\r\n                material.emissiveColor = Color3.FromArray(color);\r\n            } else if (key === \"ns\" && material) {\r\n                //value = \"Integer\"\r\n                material.specularPower = parseFloat(value);\r\n            } else if (key === \"d\" && material) {\r\n                //d is dissolve for current material. It mean alpha for BABYLON\r\n                material.alpha = parseFloat(value);\r\n\r\n                //Texture\r\n                //This part can be improved by adding the possible options of texture\r\n            } else if (key === \"map_ka\" && material) {\r\n                // ambient texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_kd\" && material) {\r\n                // Diffuse texture map with a loaded image\r\n                material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ks\" && material) {\r\n                // Specular texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ns\") {\r\n                //Specular\r\n                //Specular highlight component\r\n                //We must first get the folder of the image\r\n                //\r\n                //Not supported by BABYLON\r\n                //\r\n                //    continue;\r\n            } else if (key === \"map_bump\" && material) {\r\n                //The bump texture\r\n                const values = value.split(delimiter_pattern);\r\n                const bumpMultiplierIndex = values.indexOf(\"-bm\");\r\n                let bumpMultiplier: Nullable<string> = null;\r\n\r\n                if (bumpMultiplierIndex >= 0) {\r\n                    bumpMultiplier = values[bumpMultiplierIndex + 1];\r\n                    values.splice(bumpMultiplierIndex, 2); // remove\r\n                }\r\n\r\n                material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(\" \"), scene);\r\n                if (material.bumpTexture && bumpMultiplier !== null) {\r\n                    material.bumpTexture.level = parseFloat(bumpMultiplier);\r\n                }\r\n            } else if (key === \"map_d\" && material) {\r\n                // The dissolve of the material\r\n                material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n\r\n                //Options for illumination\r\n            } else if (key === \"illum\") {\r\n                //Illumination\r\n                if (value === \"0\") {\r\n                    //That mean Kd == Kd\r\n                } else if (value === \"1\") {\r\n                    //Color on and Ambient on\r\n                } else if (value === \"2\") {\r\n                    //Highlight on\r\n                } else if (value === \"3\") {\r\n                    //Reflection on and Ray trace on\r\n                } else if (value === \"4\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace on\r\n                } else if (value === \"5\") {\r\n                    //Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"6\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\r\n                } else if (value === \"7\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"8\") {\r\n                    //Reflection on and Ray trace off\r\n                } else if (value === \"9\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace off\r\n                } else if (value === \"10\") {\r\n                    //Casts shadows onto invisible surfaces\r\n                }\r\n            } else {\r\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\r\n            }\r\n        }\r\n        //At the end of the file, add the last material\r\n        if (material) {\r\n            this.materials.push(material);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture for the material.\r\n     *\r\n     * If the material is imported from input file,\r\n     * We sanitize the url to ensure it takes the texture from aside the material.\r\n     *\r\n     * @param rootUrl The root url to load from\r\n     * @param value The value stored in the mtl\r\n     * @param scene\r\n     * @returns The Texture\r\n     */\r\n    private static _GetTexture(rootUrl: string, value: string, scene: Scene): Nullable<Texture> {\r\n        if (!value) {\r\n            return null;\r\n        }\r\n\r\n        let url = rootUrl;\r\n        // Load from input file.\r\n        if (rootUrl === \"file:\") {\r\n            let lastDelimiter = value.lastIndexOf(\"\\\\\");\r\n            if (lastDelimiter === -1) {\r\n                lastDelimiter = value.lastIndexOf(\"/\");\r\n            }\r\n\r\n            if (lastDelimiter > -1) {\r\n                url += value.substring(lastDelimiter + 1);\r\n            } else {\r\n                url += value;\r\n            }\r\n        }\r\n        // Not from input file.\r\n        else {\r\n            url += value;\r\n        }\r\n\r\n        return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\r\n    }\r\n}\r\n","import type { AssetContainer } from \"core/assetContainer\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport { Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { OBJLoadingOptions } from \"./objLoadingOptions\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\ntype MeshObject = {\r\n    name: string;\r\n    indices: Nullable<Array<number>>;\r\n    positions: Nullable<Array<number>>;\r\n    normals: Nullable<Array<number>>;\r\n    colors: Nullable<Array<number>>;\r\n    uvs: Nullable<Array<number>>;\r\n    materialName: string;\r\n    directMaterial?: Nullable<Material>;\r\n    isObject: boolean; // If the entity is defined as an object (\"o\"), or group (\"g\")\r\n    _babylonMesh?: AbstractMesh; // The corresponding Babylon mesh\r\n    hasLines?: boolean; // If the mesh has lines\r\n};\r\n\r\n/**\r\n * Class used to load mesh data from OBJ content\r\n */\r\nexport class SolidParser {\r\n    // Descriptor\r\n    /** Object descriptor */\r\n    public static ObjectDescriptor = /^o/;\r\n    /** Group descriptor */\r\n    public static GroupDescriptor = /^g/;\r\n    /** Material lib descriptor */\r\n    public static MtlLibGroupDescriptor = /^mtllib /;\r\n    /** Use a material descriptor */\r\n    public static UseMtlDescriptor = /^usemtl /;\r\n    /** Smooth descriptor */\r\n    public static SmoothDescriptor = /^s /;\r\n\r\n    // Patterns\r\n    /** Pattern used to detect a vertex */\r\n    public static VertexPattern = /^v(\\s+[\\d|.|+|\\-|e|E]+){3,7}/;\r\n    /** Pattern used to detect a normal */\r\n    public static NormalPattern = /^vn(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a UV set */\r\n    public static UVPattern = /^vt(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a first kind of face (f vertex vertex vertex) */\r\n    public static FacePattern1 = /^f\\s+(([\\d]{1,}[\\s]?){3,})+/;\r\n    /** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */\r\n    public static FacePattern2 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */\r\n    public static FacePattern3 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/\r\n    public static FacePattern4 = /^f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */\r\n    public static FacePattern5 = /^f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a line(l vertex vertex) */\r\n    public static LinePattern1 = /^l\\s+(([\\d]{1,}[\\s]?){2,})+/;\r\n    /** Pattern used to detect a second kind of line (l vertex/uvs vertex/uvs) */\r\n    public static LinePattern2 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\r\n    /** Pattern used to detect a third kind of line (l vertex/uvs/normal vertex/uvs/normal) */\r\n    public static LinePattern3 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\r\n\r\n    private _loadingOptions: OBJLoadingOptions;\r\n    private _positions: Array<Vector3> = []; //values for the positions of vertices\r\n    private _normals: Array<Vector3> = []; //Values for the normals\r\n    private _uvs: Array<Vector2> = []; //Values for the textures\r\n    private _colors: Array<Color4> = [];\r\n    private _extColors: Array<Color4> = []; //Extension color\r\n    private _meshesFromObj: Array<MeshObject> = []; //[mesh] Contains all the obj meshes\r\n    private _handledMesh: MeshObject; //The current mesh of meshes array\r\n    private _indicesForBabylon: Array<number> = []; //The list of indices for VertexData\r\n    private _wrappedPositionForBabylon: Array<Vector3> = []; //The list of position in vectors\r\n    private _wrappedUvsForBabylon: Array<Vector2> = []; //Array with all value of uvs to match with the indices\r\n    private _wrappedColorsForBabylon: Array<Color4> = []; // Array with all color values to match with the indices\r\n    private _wrappedNormalsForBabylon: Array<Vector3> = []; //Array with all value of normals to match with the indices\r\n    private _tuplePosNorm: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }> = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\r\n    private _curPositionInIndices = 0;\r\n    private _hasMeshes: Boolean = false; //Meshes are defined in the file\r\n    private _unwrappedPositionsForBabylon: Array<number> = []; //Value of positionForBabylon w/o Vector3() [x,y,z]\r\n    private _unwrappedColorsForBabylon: Array<number> = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]\r\n    private _unwrappedNormalsForBabylon: Array<number> = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]\r\n    private _unwrappedUVForBabylon: Array<number> = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]\r\n    private _triangles: Array<string> = []; //Indices from new triangles coming from polygons\r\n    private _materialNameFromObj: string = \"\"; //The name of the current material\r\n    private _objMeshName: string = \"\"; //The name of the current obj mesh\r\n    private _increment: number = 1; //Id for meshes created by the multimaterial\r\n    private _isFirstMaterial: boolean = true;\r\n    private _grayColor = new Color4(0.5, 0.5, 0.5, 1);\r\n    private _materialToUse: string[];\r\n    private _babylonMeshesArray: Array<Mesh>;\r\n    private _pushTriangle: (faces: Array<string>, faceIndex: number) => void;\r\n    private _handednessSign: number;\r\n    private _hasLineData: boolean = false; //If this mesh has line segment(l) data\r\n\r\n    /**\r\n     * Creates a new SolidParser\r\n     * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)\r\n     * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)\r\n     * @param loadingOptions defines the loading options to use\r\n     */\r\n    public constructor(materialToUse: string[], babylonMeshesArray: Array<Mesh>, loadingOptions: OBJLoadingOptions) {\r\n        this._materialToUse = materialToUse;\r\n        this._babylonMeshesArray = babylonMeshesArray;\r\n        this._loadingOptions = loadingOptions;\r\n    }\r\n\r\n    /**\r\n     * Search for obj in the given array.\r\n     * This function is called to check if a couple of data already exists in an array.\r\n     *\r\n     * If found, returns the index of the founded tuple index. Returns -1 if not found\r\n     * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\r\n     * @param obj Array<number>\r\n     * @returns {boolean}\r\n     */\r\n    private _isInArray(arr: Array<{ normals: Array<number>; idx: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) {\r\n            arr[obj[0]] = { normals: [], idx: [] };\r\n        }\r\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        return idx === -1 ? -1 : arr[obj[0]].idx[idx];\r\n    }\r\n\r\n    private _isInArrayUV(arr: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) {\r\n            arr[obj[0]] = { normals: [], idx: [], uv: [] };\r\n        }\r\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {\r\n            return arr[obj[0]].idx[idx];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * This function set the data for each triangle.\r\n     * Data are position, normals and uvs\r\n     * If a tuple of (position, normal) is not set, add the data into the corresponding array\r\n     * If the tuple already exist, add only their indice\r\n     *\r\n     * @param indicePositionFromObj Integer The index in positions array\r\n     * @param indiceUvsFromObj Integer The index in uvs array\r\n     * @param indiceNormalFromObj Integer The index in normals array\r\n     * @param positionVectorFromOBJ Vector3 The value of position at index objIndice\r\n     * @param textureVectorFromOBJ Vector3 The value of uvs\r\n     * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale\r\n     * @param positionColorsFromOBJ\r\n     */\r\n    private _setData(\r\n        indicePositionFromObj: number,\r\n        indiceUvsFromObj: number,\r\n        indiceNormalFromObj: number,\r\n        positionVectorFromOBJ: Vector3,\r\n        textureVectorFromOBJ: Vector2,\r\n        normalsVectorFromOBJ: Vector3,\r\n        positionColorsFromOBJ?: Color4\r\n    ) {\r\n        //Check if this tuple already exists in the list of tuples\r\n        let _index: number;\r\n        if (this._loadingOptions.optimizeWithUV) {\r\n            _index = this._isInArrayUV(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj, indiceUvsFromObj]);\r\n        } else {\r\n            _index = this._isInArray(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj]);\r\n        }\r\n\r\n        //If it not exists\r\n        if (_index === -1) {\r\n            //Add an new indice.\r\n            //The array of indices is only an array with his length equal to the number of triangles - 1.\r\n            //We add vertices data in this order\r\n            this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);\r\n            //Push the position of vertice for Babylon\r\n            //Each element is a Vector3(x,y,z)\r\n            this._wrappedPositionForBabylon.push(positionVectorFromOBJ);\r\n            //Push the uvs for Babylon\r\n            //Each element is a Vector2(u,v)\r\n            //If the UVs are missing, set (u,v)=(0,0)\r\n            textureVectorFromOBJ = textureVectorFromOBJ ?? new Vector2(0, 0);\r\n            this._wrappedUvsForBabylon.push(textureVectorFromOBJ);\r\n            //Push the normals for Babylon\r\n            //Each element is a Vector3(x,y,z)\r\n            this._wrappedNormalsForBabylon.push(normalsVectorFromOBJ);\r\n\r\n            if (positionColorsFromOBJ !== undefined) {\r\n                //Push the colors for Babylon\r\n                //Each element is a BABYLON.Color4(r,g,b,a)\r\n                this._wrappedColorsForBabylon.push(positionColorsFromOBJ);\r\n            }\r\n\r\n            //Add the tuple in the comparison list\r\n            this._tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);\r\n            this._tuplePosNorm[indicePositionFromObj].idx.push(this._curPositionInIndices++);\r\n            if (this._loadingOptions.optimizeWithUV) {\r\n                this._tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);\r\n            }\r\n        } else {\r\n            //The tuple already exists\r\n            //Add the index of the already existing tuple\r\n            //At this index we can get the value of position, normal, color and uvs of vertex\r\n            this._indicesForBabylon.push(_index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform Vector() and BABYLON.Color() objects into numbers in an array\r\n     */\r\n    private _unwrapData() {\r\n        try {\r\n            //Every array has the same length\r\n            for (let l = 0; l < this._wrappedPositionForBabylon.length; l++) {\r\n                //Push the x, y, z values of each element in the unwrapped array\r\n                this._unwrappedPositionsForBabylon.push(\r\n                    this._wrappedPositionForBabylon[l].x * this._handednessSign,\r\n                    this._wrappedPositionForBabylon[l].y,\r\n                    this._wrappedPositionForBabylon[l].z\r\n                );\r\n                this._unwrappedNormalsForBabylon.push(\r\n                    this._wrappedNormalsForBabylon[l].x * this._handednessSign,\r\n                    this._wrappedNormalsForBabylon[l].y,\r\n                    this._wrappedNormalsForBabylon[l].z\r\n                );\r\n\r\n                this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\r\n                if (this._loadingOptions.importVertexColors) {\r\n                    //Push the r, g, b, a values of each element in the unwrapped array\r\n                    this._unwrappedColorsForBabylon.push(\r\n                        this._wrappedColorsForBabylon[l].r,\r\n                        this._wrappedColorsForBabylon[l].g,\r\n                        this._wrappedColorsForBabylon[l].b,\r\n                        this._wrappedColorsForBabylon[l].a\r\n                    );\r\n                }\r\n            }\r\n            // Reset arrays for the next new meshes\r\n            this._wrappedPositionForBabylon.length = 0;\r\n            this._wrappedNormalsForBabylon.length = 0;\r\n            this._wrappedUvsForBabylon.length = 0;\r\n            this._wrappedColorsForBabylon.length = 0;\r\n            this._tuplePosNorm.length = 0;\r\n            this._curPositionInIndices = 0;\r\n        } catch (e) {\r\n            throw new Error(\"Unable to unwrap data while parsing OBJ data.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create triangles from polygons\r\n     * It is important to notice that a triangle is a polygon\r\n     * We get 5 patterns of face defined in OBJ File :\r\n     * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\r\n     * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\r\n     * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\r\n     * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\r\n     * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\r\n     * Each pattern is divided by the same method\r\n     * @param faces Array[String] The indices of elements\r\n     * @param v Integer The variable to increment\r\n     */\r\n    private _getTriangles(faces: Array<string>, v: number) {\r\n        //Work for each element of the array\r\n        for (let faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\r\n            //Add on the triangle variable the indexes to obtain triangles\r\n            this._pushTriangle(faces, faceIndex);\r\n        }\r\n\r\n        //Result obtained after 2 iterations:\r\n        //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\r\n        //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\r\n        //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\r\n        //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\r\n        //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\r\n    }\r\n\r\n    /**\r\n     * To get color between color and extension color\r\n     * @param index Integer The index of the element in the array\r\n     * @returns value of target color\r\n     */\r\n    private _getColor(index: number) {\r\n        if (this._loadingOptions.importVertexColors) {\r\n            return this._extColors[index] ?? this._colors[index];\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 1\r\n     * In this pattern we get vertice positions\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern1(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        //For each element in the triangles array.\r\n        //This var could contains 1 to an infinity of triangles\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            // Set position indice\r\n            const indicePositionFromObj = parseInt(this._triangles[k]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                0,\r\n                0, // In the pattern 1, normals and uvs are not defined\r\n                this._positions[indicePositionFromObj], // Get the vectors data\r\n                Vector2.Zero(),\r\n                Vector3.Up(), // Create default vectors\r\n                this._getColor(indicePositionFromObj)\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 2\r\n     * In this pattern we get vertice positions and uvs\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern2(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1\"\r\n            //Split the data for getting position and uv\r\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\"]\r\n            //Set position indice\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            //Set uv indice\r\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                0, //Default value for normals\r\n                this._positions[indicePositionFromObj], //Get the values for each element\r\n                this._uvs[indiceUvsFromObj] ?? Vector2.Zero(),\r\n                Vector3.Up(), //Default value for normals\r\n                this._getColor(indicePositionFromObj)\r\n            );\r\n        }\r\n\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern3(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1/1\"\r\n            //Split the data for getting position, uv, and normals\r\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\r\n            // Set position indice\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            // Set uv indice\r\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\r\n            // Set normal indice\r\n            const indiceNormalFromObj = parseInt(point[2]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj],\r\n                this._uvs[indiceUvsFromObj] ?? Vector2.Zero(),\r\n                this._normals[indiceNormalFromObj] ?? Vector3.Up() //Set the vector for each component\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 4\r\n     * In this pattern we get vertice positions and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern4(face: Array<string>, v: number) {\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1//1\"\r\n            //Split the data for getting position and normals\r\n            const point = this._triangles[k].split(\"//\"); // [\"1\", \"1\"]\r\n            // We check indices, and normals\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            const indiceNormalFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                1, //Default value for uv\r\n                indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj], //Get each vector of data\r\n                Vector2.Zero(),\r\n                this._normals[indiceNormalFromObj],\r\n                this._getColor(indicePositionFromObj)\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /*\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern5(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"-1/-1/-1\"\r\n            //Split the data for getting position, uv, and normals\r\n            const point = this._triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\r\n            // Set position indice\r\n            const indicePositionFromObj = this._positions.length + parseInt(point[0]);\r\n            // Set uv indice\r\n            const indiceUvsFromObj = this._uvs.length + parseInt(point[1]);\r\n            // Set normal indice\r\n            const indiceNormalFromObj = this._normals.length + parseInt(point[2]);\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj],\r\n                this._uvs[indiceUvsFromObj],\r\n                this._normals[indiceNormalFromObj], //Set the vector for each component\r\n                this._getColor(indicePositionFromObj)\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    private _addPreviousObjMesh() {\r\n        //Check if it is not the first mesh. Otherwise we don't have data.\r\n        if (this._meshesFromObj.length > 0) {\r\n            //Get the previous mesh for applying the data about the faces\r\n            //=> in obj file, faces definition append after the name of the mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            //Set the data into Array for the mesh\r\n            this._unwrapData();\r\n\r\n            if (this._loadingOptions.useLegacyBehavior) {\r\n                // Reverse tab. Otherwise face are displayed in the wrong sens\r\n                this._indicesForBabylon.reverse();\r\n            }\r\n\r\n            //Set the information for the mesh\r\n            //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\r\n            this._handledMesh.indices = this._indicesForBabylon.slice();\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();\r\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();\r\n            this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();\r\n            this._handledMesh.hasLines = this._hasLineData;\r\n\r\n            if (this._loadingOptions.importVertexColors) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();\r\n            }\r\n\r\n            //Reset the array for the next mesh\r\n            this._indicesForBabylon.length = 0;\r\n            this._unwrappedPositionsForBabylon.length = 0;\r\n            this._unwrappedColorsForBabylon.length = 0;\r\n            this._unwrappedNormalsForBabylon.length = 0;\r\n            this._unwrappedUVForBabylon.length = 0;\r\n            this._hasLineData = false;\r\n        }\r\n    }\r\n\r\n    private _optimizeNormals(mesh: AbstractMesh): void {\r\n        const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const normals = mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        const mapVertices: { [key: string]: number[] } = {};\r\n\r\n        if (!positions || !normals) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < positions.length / 3; i++) {\r\n            const x = positions[i * 3 + 0];\r\n            const y = positions[i * 3 + 1];\r\n            const z = positions[i * 3 + 2];\r\n            const key = x + \"_\" + y + \"_\" + z;\r\n\r\n            let lst = mapVertices[key];\r\n            if (!lst) {\r\n                lst = [];\r\n                mapVertices[key] = lst;\r\n            }\r\n            lst.push(i);\r\n        }\r\n\r\n        const normal = new Vector3();\r\n        for (const key in mapVertices) {\r\n            const lst = mapVertices[key];\r\n            if (lst.length < 2) {\r\n                continue;\r\n            }\r\n\r\n            const v0Idx = lst[0];\r\n            for (let i = 1; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];\r\n                normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];\r\n                normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];\r\n            }\r\n\r\n            normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);\r\n            normal.normalize();\r\n\r\n            for (let i = 0; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[vIdx * 3 + 0] = normal.x;\r\n                normals[vIdx * 3 + 1] = normal.y;\r\n                normals[vIdx * 3 + 2] = normal.z;\r\n            }\r\n        }\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n    }\r\n\r\n    private static _IsLineElement(line: string) {\r\n        return line.startsWith(\"l\");\r\n    }\r\n\r\n    private static _IsObjectElement(line: string) {\r\n        return line.startsWith(\"o\");\r\n    }\r\n\r\n    private static _IsGroupElement(line: string) {\r\n        return line.startsWith(\"g\");\r\n    }\r\n\r\n    private static _GetZbrushMRGB(line: string, notParse: boolean) {\r\n        if (!line.startsWith(\"mrgb\")) return null;\r\n        line = line.replace(\"mrgb\", \"\").trim();\r\n        // if include vertex color , not load mrgb anymore\r\n        if (notParse) return [];\r\n        const regex = /[a-z0-9]/g;\r\n        const regArray = line.match(regex);\r\n        if (!regArray || regArray.length % 8 !== 0) {\r\n            return [];\r\n        }\r\n        const array: Color4[] = [];\r\n        for (let regIndex = 0; regIndex < regArray.length / 8; regIndex++) {\r\n            //each item is MMRRGGBB, m is material index\r\n            // const m = regArray[regIndex * 8 + 0] + regArray[regIndex * 8 + 1];\r\n            const r = regArray[regIndex * 8 + 2] + regArray[regIndex * 8 + 3];\r\n            const g = regArray[regIndex * 8 + 4] + regArray[regIndex * 8 + 5];\r\n            const b = regArray[regIndex * 8 + 6] + regArray[regIndex * 8 + 7];\r\n            array.push(new Color4(parseInt(r, 16) / 255, parseInt(g, 16) / 255, parseInt(b, 16) / 255, 1));\r\n        }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Function used to parse an OBJ string\r\n     * @param meshesNames defines the list of meshes to load (all if not defined)\r\n     * @param data defines the OBJ string\r\n     * @param scene defines the hosting scene\r\n     * @param assetContainer defines the asset container to load data in\r\n     * @param onFileToLoadFound defines a callback that will be called if a MTL file is found\r\n     */\r\n    public parse(meshesNames: any, data: string, scene: Scene, assetContainer: Nullable<AssetContainer>, onFileToLoadFound: (fileToLoad: string) => void): void {\r\n        //Move Santitize here to forbid delete zbrush data\r\n        // Sanitize data\r\n        data = data.replace(/#MRGB/g, \"mrgb\");\r\n        data = data.replace(/#.*$/gm, \"\").trim();\r\n        if (this._loadingOptions.useLegacyBehavior) {\r\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\r\n            this._handednessSign = 1;\r\n        } else if (scene.useRightHandedSystem) {\r\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex + 1], faces[faceIndex]);\r\n            this._handednessSign = 1;\r\n        } else {\r\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\r\n            this._handednessSign = -1;\r\n        }\r\n\r\n        // Split the file into lines\r\n        // Preprocess line data\r\n        const linesOBJ = data.split(\"\\n\");\r\n        const lineLines: string[][] = [];\r\n        let currentGroup: string[] = [];\r\n\r\n        lineLines.push(currentGroup);\r\n\r\n        for (let i = 0; i < linesOBJ.length; i++) {\r\n            const line = linesOBJ[i].trim().replace(/\\s\\s/g, \" \");\r\n\r\n            // Comment or newLine\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            }\r\n\r\n            if (SolidParser._IsGroupElement(line) || SolidParser._IsObjectElement(line)) {\r\n                currentGroup = [];\r\n                lineLines.push(currentGroup);\r\n            }\r\n\r\n            if (SolidParser._IsLineElement(line)) {\r\n                const lineValues = line.split(\" \");\r\n                // create line elements with two vertices only\r\n                for (let i = 1; i < lineValues.length - 1; i++) {\r\n                    currentGroup.push(`l ${lineValues[i]} ${lineValues[i + 1]}`);\r\n                }\r\n            } else {\r\n                currentGroup.push(line);\r\n            }\r\n        }\r\n\r\n        const lines = lineLines.flat();\r\n        // Look at each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i].trim().replace(/\\s\\s/g, \" \");\r\n            let result;\r\n            // Comment or newLine\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            } else if (SolidParser.VertexPattern.test(line)) {\r\n                //Get information about one position possible for the vertices\r\n                result = line.match(/[^ ]+/g)!; // match will return non-null due to passing regex pattern\r\n\r\n                // Value of result with line: \"v 1.0 2.0 3.0\"\r\n                // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\r\n                // Create a Vector3 with the position x, y, z\r\n                this._positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\r\n\r\n                if (this._loadingOptions.importVertexColors) {\r\n                    if (result.length >= 7) {\r\n                        const r = parseFloat(result[4]);\r\n                        const g = parseFloat(result[5]);\r\n                        const b = parseFloat(result[6]);\r\n\r\n                        this._colors.push(\r\n                            new Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7]))\r\n                        );\r\n                    } else {\r\n                        // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\r\n                        this._colors.push(this._grayColor);\r\n                    }\r\n                }\r\n            } else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {\r\n                //Create a Vector3 with the normals x, y, z\r\n                //Value of result\r\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\r\n                //Add the Vector in the list of normals\r\n                this._normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\r\n            } else if ((result = SolidParser.UVPattern.exec(line)) !== null) {\r\n                //Create a Vector2 with the normals u, v\r\n                //Value of result\r\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\r\n                //Add the Vector in the list of uvs\r\n                this._uvs.push(new Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));\r\n\r\n                //Identify patterns of faces\r\n                //Face could be defined in different type of pattern\r\n            } else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern3(\r\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern4(\r\n                    result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern5(\r\n                    result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern2(\r\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"f 1 2 3\", \"1 2 3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern1(\r\n                    result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\r\n                    1\r\n                );\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if ((result = SolidParser.LinePattern1.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"l 1 2\"]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern1(\r\n                    result[1].trim().split(\" \"), // [\"1\", \"2\"]\r\n                    0\r\n                );\r\n                this._hasLineData = true;\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if ((result = SolidParser.LinePattern2.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"l 1/1 2/2\"]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern2(\r\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\"]\r\n                    0\r\n                );\r\n                this._hasLineData = true;\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if ((result = SolidParser._GetZbrushMRGB(line, !this._loadingOptions.importVertexColors))) {\r\n                result.forEach((element) => {\r\n                    this._extColors.push(element);\r\n                });\r\n            } else if ((result = SolidParser.LinePattern3.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"l 1/1/1 2/2/2\"]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern3(\r\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\"]\r\n                    0\r\n                );\r\n                this._hasLineData = true;\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {\r\n                // Create a new mesh corresponding to the name of the group.\r\n                // Definition of the mesh\r\n                const objMesh: MeshObject = {\r\n                    name: line.substring(2).trim(), //Set the name of the current obj mesh\r\n                    indices: null,\r\n                    positions: null,\r\n                    normals: null,\r\n                    uvs: null,\r\n                    colors: null,\r\n                    materialName: this._materialNameFromObj,\r\n                    isObject: SolidParser.ObjectDescriptor.test(line),\r\n                };\r\n                this._addPreviousObjMesh();\r\n\r\n                //Push the last mesh created with only the name\r\n                this._meshesFromObj.push(objMesh);\r\n\r\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\r\n                this._hasMeshes = true;\r\n                this._isFirstMaterial = true;\r\n                this._increment = 1;\r\n                //Keyword for applying a material\r\n            } else if (SolidParser.UseMtlDescriptor.test(line)) {\r\n                //Get the name of the material\r\n                this._materialNameFromObj = line.substring(7).trim();\r\n\r\n                //If this new material is in the same mesh\r\n\r\n                if (!this._isFirstMaterial || !this._hasMeshes) {\r\n                    //Set the data for the previous mesh\r\n                    this._addPreviousObjMesh();\r\n                    //Create a new mesh\r\n                    const objMesh: MeshObject =\r\n                        //Set the name of the current obj mesh\r\n                        {\r\n                            name: (this._objMeshName || \"mesh\") + \"_mm\" + this._increment.toString(), //Set the name of the current obj mesh\r\n                            indices: null,\r\n                            positions: null,\r\n                            normals: null,\r\n                            uvs: null,\r\n                            colors: null,\r\n                            materialName: this._materialNameFromObj,\r\n                            isObject: false,\r\n                        };\r\n                    this._increment++;\r\n                    //If meshes are already defined\r\n                    this._meshesFromObj.push(objMesh);\r\n                    this._hasMeshes = true;\r\n                }\r\n                //Set the material name if the previous line define a mesh\r\n\r\n                if (this._hasMeshes && this._isFirstMaterial) {\r\n                    //Set the material name to the previous mesh (1 material per mesh)\r\n                    this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;\r\n                    this._isFirstMaterial = false;\r\n                }\r\n                // Keyword for loading the mtl file\r\n            } else if (SolidParser.MtlLibGroupDescriptor.test(line)) {\r\n                // Get the name of mtl file\r\n                onFileToLoadFound(line.substring(7).trim());\r\n\r\n                // Apply smoothing\r\n            } else if (SolidParser.SmoothDescriptor.test(line)) {\r\n                // smooth shading => apply smoothing\r\n                // Today I don't know it work with babylon and with obj.\r\n                // With the obj file  an integer is set\r\n            } else {\r\n                //If there is another possibility\r\n                Logger.Log(\"Unhandled expression at line : \" + line);\r\n            }\r\n        }\r\n        // At the end of the file, add the last mesh into the meshesFromObj array\r\n        if (this._hasMeshes) {\r\n            // Set the data for the last mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            if (this._loadingOptions.useLegacyBehavior) {\r\n                //Reverse indices for displaying faces in the good sense\r\n                this._indicesForBabylon.reverse();\r\n            }\r\n\r\n            //Get the good array\r\n            this._unwrapData();\r\n            //Set array\r\n            this._handledMesh.indices = this._indicesForBabylon;\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon;\r\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon;\r\n            this._handledMesh.uvs = this._unwrappedUVForBabylon;\r\n            this._handledMesh.hasLines = this._hasLineData;\r\n            if (this._loadingOptions.importVertexColors) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon;\r\n            }\r\n        }\r\n\r\n        // If any o or g keyword not found, create a mesh with a random id\r\n        if (!this._hasMeshes) {\r\n            let newMaterial: Nullable<StandardMaterial> = null;\r\n            if (this._indicesForBabylon.length) {\r\n                if (this._loadingOptions.useLegacyBehavior) {\r\n                    // reverse tab of indices\r\n                    this._indicesForBabylon.reverse();\r\n                }\r\n\r\n                //Get positions normals uvs\r\n                this._unwrapData();\r\n            } else {\r\n                // There is no indices in the file. We will have to switch to point cloud rendering\r\n                for (const pos of this._positions) {\r\n                    this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);\r\n                }\r\n\r\n                if (this._normals.length) {\r\n                    for (const normal of this._normals) {\r\n                        this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);\r\n                    }\r\n                }\r\n\r\n                if (this._uvs.length) {\r\n                    for (const uv of this._uvs) {\r\n                        this._unwrappedUVForBabylon.push(uv.x, uv.y);\r\n                    }\r\n                }\r\n\r\n                if (this._extColors.length) {\r\n                    for (const color of this._extColors) {\r\n                        this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\r\n                    }\r\n                } else {\r\n                    if (this._colors.length) {\r\n                        for (const color of this._colors) {\r\n                            this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!this._materialNameFromObj) {\r\n                    // Create a material with point cloud on\r\n                    newMaterial = new StandardMaterial(Geometry.RandomId(), scene);\r\n\r\n                    newMaterial.pointsCloud = true;\r\n\r\n                    this._materialNameFromObj = newMaterial.name;\r\n\r\n                    if (!this._normals.length) {\r\n                        newMaterial.disableLighting = true;\r\n                        newMaterial.emissiveColor = Color3.White();\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Set data for one mesh\r\n            this._meshesFromObj.push({\r\n                name: Geometry.RandomId(),\r\n                indices: this._indicesForBabylon,\r\n                positions: this._unwrappedPositionsForBabylon,\r\n                colors: this._unwrappedColorsForBabylon,\r\n                normals: this._unwrappedNormalsForBabylon,\r\n                uvs: this._unwrappedUVForBabylon,\r\n                materialName: this._materialNameFromObj,\r\n                directMaterial: newMaterial,\r\n                isObject: true,\r\n                hasLines: this._hasLineData,\r\n            });\r\n        }\r\n\r\n        //Set data for each mesh\r\n        for (let j = 0; j < this._meshesFromObj.length; j++) {\r\n            //check meshesNames (stlFileLoader)\r\n            if (meshesNames && this._meshesFromObj[j].name) {\r\n                if (meshesNames instanceof Array) {\r\n                    if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    if (this._meshesFromObj[j].name !== meshesNames) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Get the current mesh\r\n            //Set the data with VertexBuffer for each mesh\r\n            this._handledMesh = this._meshesFromObj[j];\r\n            //Create a Mesh with the name of the obj mesh\r\n\r\n            scene._blockEntityCollection = !!assetContainer;\r\n            const babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);\r\n            babylonMesh._parentContainer = assetContainer;\r\n            scene._blockEntityCollection = false;\r\n            this._handledMesh._babylonMesh = babylonMesh;\r\n            // If this is a group mesh, it should have an object mesh as a parent. So look for the first object mesh that appears before it.\r\n            if (!this._handledMesh.isObject) {\r\n                for (let k = j - 1; k >= 0; --k) {\r\n                    if (this._meshesFromObj[k].isObject && this._meshesFromObj[k]._babylonMesh) {\r\n                        babylonMesh.parent = this._meshesFromObj[k]._babylonMesh!;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Push the name of the material to an array\r\n            //This is indispensable for the importMesh function\r\n            this._materialToUse.push(this._meshesFromObj[j].materialName);\r\n            //If the mesh is a line mesh\r\n            if (this._handledMesh.hasLines) {\r\n                babylonMesh._internalMetadata ??= {};\r\n                babylonMesh._internalMetadata[\"_isLine\"] = true; //this is a line mesh\r\n            }\r\n\r\n            if (this._handledMesh.positions?.length === 0) {\r\n                //Push the mesh into an array\r\n                this._babylonMeshesArray.push(babylonMesh);\r\n                continue;\r\n            }\r\n\r\n            const vertexData: VertexData = new VertexData(); //The container for the values\r\n            //Set the data for the babylonMesh\r\n            vertexData.uvs = this._handledMesh.uvs;\r\n            vertexData.indices = this._handledMesh.indices;\r\n            vertexData.positions = this._handledMesh.positions;\r\n            if (this._loadingOptions.computeNormals) {\r\n                const normals: Array<number> = new Array<number>();\r\n                VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);\r\n                vertexData.normals = normals;\r\n            } else {\r\n                vertexData.normals = this._handledMesh.normals;\r\n            }\r\n            if (this._loadingOptions.importVertexColors) {\r\n                vertexData.colors = this._handledMesh.colors;\r\n            }\r\n            //Set the data from the VertexBuffer to the current Mesh\r\n            vertexData.applyToMesh(babylonMesh);\r\n            if (this._loadingOptions.invertY) {\r\n                babylonMesh.scaling.y *= -1;\r\n            }\r\n            if (this._loadingOptions.optimizeNormals) {\r\n                this._optimizeNormals(babylonMesh);\r\n            }\r\n\r\n            //Push the mesh into an array\r\n            this._babylonMeshesArray.push(babylonMesh);\r\n\r\n            if (this._handledMesh.directMaterial) {\r\n                babylonMesh.material = this._handledMesh.directMaterial;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import type { Nullable } from \"core/types\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, ISceneLoaderPlugin, ISceneLoaderAsyncResult } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport { OBJFileLoaderMetadata } from \"./objFileLoader.metadata\";\r\nimport { MTLFileLoader } from \"./mtlFileLoader\";\r\nimport type { OBJLoadingOptions } from \"./objLoadingOptions\";\r\nimport { SolidParser } from \"./solidParser\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the obj loader.\r\n         */\r\n        [OBJFileLoaderMetadata.name]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * OBJ file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\r\nexport class OBJFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines if UVs are optimized by default during load.\r\n     */\r\n    public static OPTIMIZE_WITH_UV = true;\r\n    /**\r\n     * Invert model on y-axis (does a model scaling inversion)\r\n     */\r\n    public static INVERT_Y = false;\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static get INVERT_TEXTURE_Y() {\r\n        return MTLFileLoader.INVERT_TEXTURE_Y;\r\n    }\r\n\r\n    public static set INVERT_TEXTURE_Y(value: boolean) {\r\n        MTLFileLoader.INVERT_TEXTURE_Y = value;\r\n    }\r\n\r\n    /**\r\n     * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\r\n     */\r\n    public static IMPORT_VERTEX_COLORS = false;\r\n    /**\r\n     * Compute the normals for the model, even if normals are present in the file.\r\n     */\r\n    public static COMPUTE_NORMALS = false;\r\n    /**\r\n     * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\r\n     * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\r\n     */\r\n    public static OPTIMIZE_NORMALS = false;\r\n    /**\r\n     * Defines custom scaling of UV coordinates of loaded meshes.\r\n     */\r\n    public static UV_SCALING = new Vector2(1, 1);\r\n    /**\r\n     * Skip loading the materials even if defined in the OBJ file (materials are ignored).\r\n     */\r\n    public static SKIP_MATERIALS = false;\r\n\r\n    /**\r\n     * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\r\n     *\r\n     * Defaults to true for backwards compatibility.\r\n     */\r\n    public static MATERIAL_LOADING_FAILS_SILENTLY = true;\r\n\r\n    /**\r\n     * Loads assets without handedness conversions. This flag is for compatibility. Use it only if absolutely required. Defaults to false.\r\n     */\r\n    public static USE_LEGACY_BEHAVIOR = false;\r\n\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public readonly name = OBJFileLoaderMetadata.name;\r\n    /**\r\n     * Defines the extension the plugin is able to load.\r\n     */\r\n    public readonly extensions = OBJFileLoaderMetadata.extensions;\r\n\r\n    private _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    private _loadingOptions: OBJLoadingOptions;\r\n\r\n    /**\r\n     * Creates loader for .OBJ files\r\n     *\r\n     * @param loadingOptions options for loading and parsing OBJ/MTL files.\r\n     */\r\n    constructor(loadingOptions?: OBJLoadingOptions) {\r\n        this._loadingOptions = loadingOptions || OBJFileLoader._DefaultLoadingOptions;\r\n    }\r\n\r\n    private static get _DefaultLoadingOptions(): OBJLoadingOptions {\r\n        return {\r\n            computeNormals: OBJFileLoader.COMPUTE_NORMALS,\r\n            optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\r\n            importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\r\n            invertY: OBJFileLoader.INVERT_Y,\r\n            invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            UVScaling: OBJFileLoader.UV_SCALING,\r\n            materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\r\n            optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\r\n            skipMaterials: OBJFileLoader.SKIP_MATERIALS,\r\n            useLegacyBehavior: OBJFileLoader.USE_LEGACY_BEHAVIOR,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calls synchronously the MTL file attached to this obj.\r\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\r\n     * Without this function materials are not displayed in the first frame (but displayed after).\r\n     * In consequence it is impossible to get material information in your HTML file\r\n     *\r\n     * @param url The URL of the MTL file\r\n     * @param rootUrl defines where to load data from\r\n     * @param onSuccess Callback function to be called when the MTL file is loaded\r\n     * @param onFailure\r\n     */\r\n    private _loadMTL(\r\n        url: string,\r\n        rootUrl: string,\r\n        onSuccess: (response: string | ArrayBuffer, responseUrl?: string) => any,\r\n        onFailure: (pathOfFile: string, exception?: any) => void\r\n    ) {\r\n        //The complete path to the mtl file\r\n        const pathOfFile = rootUrl + url;\r\n\r\n        // Loads through the babylon tools to allow fileInput search.\r\n        Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, (request?: WebRequest | undefined, exception?: any) => {\r\n            onFailure(pathOfFile, exception);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Instantiates a OBJ file loader plugin.\r\n     * @returns the created plugin\r\n     */\r\n    createPlugin(): ISceneLoaderPluginAsync | ISceneLoaderPlugin {\r\n        return new OBJFileLoader(OBJFileLoader._DefaultLoadingOptions);\r\n    }\r\n\r\n    /**\r\n     * If the data string can be loaded directly.\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    public canDirectLoad(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from the loaded OBJ data and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\r\n     */\r\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string): Promise<ISceneLoaderAsyncResult> {\r\n        //get the meshes from OBJ file\r\n        return this._parseSolid(meshesNames, scene, data, rootUrl).then((meshes) => {\r\n            return {\r\n                meshes: meshes,\r\n                particleSystems: [],\r\n                skeletons: [],\r\n                animationGroups: [],\r\n                transformNodes: [],\r\n                geometries: [],\r\n                lights: [],\r\n                spriteManagers: [],\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from the loaded OBJ data and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public loadAsync(scene: Scene, data: string, rootUrl: string): Promise<void> {\r\n        //Get the 3D model\r\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\r\n            // return void\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns The loaded asset container\r\n     */\r\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string): Promise<AssetContainer> {\r\n        const container = new AssetContainer(scene);\r\n        this._assetContainer = container;\r\n\r\n        return this.importMeshAsync(null, scene, data, rootUrl)\r\n            .then((result) => {\r\n                result.meshes.forEach((mesh) => container.meshes.push(mesh));\r\n                result.meshes.forEach((mesh) => {\r\n                    const material = mesh.material;\r\n                    if (material) {\r\n                        // Materials\r\n                        if (container.materials.indexOf(material) == -1) {\r\n                            container.materials.push(material);\r\n\r\n                            // Textures\r\n                            const textures = material.getActiveTextures();\r\n                            textures.forEach((t) => {\r\n                                if (container.textures.indexOf(t) == -1) {\r\n                                    container.textures.push(t);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n                this._assetContainer = null;\r\n                return container;\r\n            })\r\n            .catch((ex) => {\r\n                this._assetContainer = null;\r\n                throw ex;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Read the OBJ file and create an Array of meshes.\r\n     * Each mesh contains all information given by the OBJ and the MTL file.\r\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\r\n     * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene defines the scene where are displayed the data\r\n     * @param data defines the content of the obj file\r\n     * @param rootUrl defines the path to the folder\r\n     * @returns the list of loaded meshes\r\n     */\r\n    private _parseSolid(meshesNames: any, scene: Scene, data: string, rootUrl: string): Promise<Array<AbstractMesh>> {\r\n        let fileToLoad: string = \"\"; //The name of the mtlFile to load\r\n        const materialsFromMTLFile: MTLFileLoader = new MTLFileLoader();\r\n        const materialToUse: string[] = [];\r\n        const babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\r\n\r\n        // Sanitize data\r\n        data = data.replace(/#.*$/gm, \"\").trim();\r\n\r\n        // Main function\r\n        const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\r\n\r\n        solidParser.parse(meshesNames, data, scene, this._assetContainer, (fileName: string) => {\r\n            fileToLoad = fileName;\r\n        });\r\n\r\n        // load the materials\r\n        const mtlPromises: Array<Promise<void>> = [];\r\n        // Check if we have a file to load\r\n        if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\r\n            //Load the file synchronously\r\n            mtlPromises.push(\r\n                new Promise((resolve, reject) => {\r\n                    this._loadMTL(\r\n                        fileToLoad,\r\n                        rootUrl,\r\n                        (dataLoaded) => {\r\n                            try {\r\n                                //Create materials thanks MTLLoader function\r\n                                materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);\r\n                                //Look at each material loaded in the mtl file\r\n                                for (let n = 0; n < materialsFromMTLFile.materials.length; n++) {\r\n                                    //Three variables to get all meshes with the same material\r\n                                    let startIndex = 0;\r\n                                    const _indices = [];\r\n                                    let _index;\r\n\r\n                                    //The material from MTL file is used in the meshes loaded\r\n                                    //Push the indice in an array\r\n                                    //Check if the material is not used for another mesh\r\n                                    while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\r\n                                        _indices.push(_index);\r\n                                        startIndex = _index + 1;\r\n                                    }\r\n                                    //If the material is not used dispose it\r\n                                    if (_index === -1 && _indices.length === 0) {\r\n                                        //If the material is not needed, remove it\r\n                                        materialsFromMTLFile.materials[n].dispose();\r\n                                    } else {\r\n                                        for (let o = 0; o < _indices.length; o++) {\r\n                                            //Apply the material to the Mesh for each mesh with the material\r\n                                            const mesh = babylonMeshesArray[_indices[o]];\r\n                                            const material = materialsFromMTLFile.materials[n];\r\n                                            mesh.material = material;\r\n\r\n                                            if (!mesh.getTotalIndices()) {\r\n                                                // No indices, we need to turn on point cloud\r\n                                                material.pointsCloud = true;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                resolve();\r\n                            } catch (e) {\r\n                                Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);\r\n                                if (this._loadingOptions.materialLoadingFailsSilently) {\r\n                                    resolve();\r\n                                } else {\r\n                                    reject(e);\r\n                                }\r\n                            }\r\n                        },\r\n                        (pathOfFile: string, exception?: any) => {\r\n                            Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);\r\n                            if (this._loadingOptions.materialLoadingFailsSilently) {\r\n                                resolve();\r\n                            } else {\r\n                                reject(exception);\r\n                            }\r\n                        }\r\n                    );\r\n                })\r\n            );\r\n        }\r\n        //Return an array with all Mesh\r\n        return Promise.all(mtlPromises).then(() => {\r\n            const isLine = (mesh: AbstractMesh) => Boolean(mesh._internalMetadata?.[\"_isLine\"] ?? false);\r\n\r\n            // Iterate over the mesh, determine if it is a line mesh, clone or modify the material to line rendering.\r\n            babylonMeshesArray.forEach((mesh) => {\r\n                if (isLine(mesh)) {\r\n                    let mat = mesh.material ?? new StandardMaterial(mesh.name + \"_line\", scene);\r\n                    // If another mesh is using this material and it is not a line then we need to clone it.\r\n                    const needClone = mat.getBindedMeshes().filter((e) => !isLine(e)).length > 0;\r\n                    if (needClone) {\r\n                        mat = mat.clone(mat.name + \"_line\") ?? mat;\r\n                    }\r\n                    mat.wireframe = true;\r\n                    mesh.material = mat;\r\n                    if (mesh._internalMetadata) {\r\n                        mesh._internalMetadata[\"_isLine\"] = undefined;\r\n                    }\r\n                }\r\n            });\r\n\r\n            return babylonMeshesArray;\r\n        });\r\n    }\r\n}\r\n\r\n//Add this loader into the register plugin\r\nRegisterSceneLoaderPlugin(new OBJFileLoader());\r\n","// eslint-disable-next-line import/no-internal-modules\r\nimport type { ISceneLoaderPluginMetadata } from \"core/index\";\r\n\r\nexport const OBJFileLoaderMetadata = {\r\n    name: \"obj\",\r\n    extensions: \".obj\",\r\n} as const satisfies ISceneLoaderPluginMetadata;\r\n","/* eslint-disable import/no-internal-modules */\r\nimport * as Loaders from \"loaders/OBJ/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof globalObject !== \"undefined\") {\r\n    for (const key in Loaders) {\r\n        if (!(<any>globalObject).BABYLON[key]) {\r\n            (<any>globalObject).BABYLON[key] = (<any>Loaders)[key];\r\n        }\r\n    }\r\n}\r\n\r\nexport * from \"loaders/OBJ/index\";\r\n","import * as loaders from \"@lts/loaders/legacy/legacy-objFileLoader\";\r\nexport { loaders };\r\nexport default loaders;\r\n"],"names":["root","factory","exports","module","require","define","amd","self","global","this","__WEBPACK_EXTERNAL_MODULE__597__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","Function","e","window","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","materials","parseMTL","scene","data","rootUrl","assetContainer","ArrayBuffer","color","lines","split","delimiter_pattern","material","i","length","line","trim","charAt","pos","indexOf","substring","toLowerCase","push","_blockEntityCollection","StandardMaterial","_parentContainer","map","parseFloat","diffuseColor","Color3","FromArray","ambientColor","specularColor","emissiveColor","specularPower","alpha","ambientTexture","MTLFileLoader","_GetTexture","diffuseTexture","specularTexture","values","bumpMultiplierIndex","bumpMultiplier","splice","bumpTexture","join","level","opacityTexture","url","lastDelimiter","lastIndexOf","Texture","INVERT_TEXTURE_Y","materialToUse","babylonMeshesArray","loadingOptions","_positions","_normals","_uvs","_colors","_extColors","_meshesFromObj","_indicesForBabylon","_wrappedPositionForBabylon","_wrappedUvsForBabylon","_wrappedColorsForBabylon","_wrappedNormalsForBabylon","_tuplePosNorm","_curPositionInIndices","_hasMeshes","_unwrappedPositionsForBabylon","_unwrappedColorsForBabylon","_unwrappedNormalsForBabylon","_unwrappedUVForBabylon","_triangles","_materialNameFromObj","_objMeshName","_increment","_isFirstMaterial","_grayColor","Color4","_hasLineData","_materialToUse","_babylonMeshesArray","_loadingOptions","_isInArray","arr","normals","idx","_isInArrayUV","uv","_setData","indicePositionFromObj","indiceUvsFromObj","indiceNormalFromObj","positionVectorFromOBJ","textureVectorFromOBJ","normalsVectorFromOBJ","positionColorsFromOBJ","_index","optimizeWithUV","Vector2","_unwrapData","l","x","_handednessSign","y","z","importVertexColors","b","a","Error","_getTriangles","faces","v","faceIndex","_pushTriangle","_getColor","index","_setDataForCurrentFaceWithPattern1","face","k","parseInt","Zero","Vector3","Up","_setDataForCurrentFaceWithPattern2","point","_setDataForCurrentFaceWithPattern3","_setDataForCurrentFaceWithPattern4","_setDataForCurrentFaceWithPattern5","_addPreviousObjMesh","_handledMesh","useLegacyBehavior","reverse","indices","slice","positions","uvs","hasLines","colors","_optimizeNormals","mesh","getVerticesData","VertexBuffer","PositionKind","NormalKind","mapVertices","lst","normal","v0Idx","vIdx","copyFromFloats","normalize","setVerticesData","_IsLineElement","startsWith","_IsObjectElement","_IsGroupElement","_GetZbrushMRGB","notParse","replace","regArray","match","array","regIndex","parse","meshesNames","onFileToLoadFound","useRightHandedSystem","linesOBJ","lineLines","currentGroup","SolidParser","lineValues","flat","result","VertexPattern","test","NormalPattern","exec","UVPattern","UVScaling","FacePattern3","FacePattern4","FacePattern5","FacePattern2","FacePattern1","LinePattern1","LinePattern2","forEach","element","LinePattern3","GroupDescriptor","ObjectDescriptor","objMesh","name","materialName","isObject","UseMtlDescriptor","toString","MtlLibGroupDescriptor","SmoothDescriptor","Logger","Log","newMaterial","Geometry","RandomId","pointsCloud","disableLighting","White","directMaterial","j","Array","babylonMesh","Mesh","_babylonMesh","parent","_internalMetadata","vertexData","VertexData","computeNormals","ComputeNormals","applyToMesh","invertY","scaling","optimizeNormals","extensions","_assetContainer","OBJFileLoader","_DefaultLoadingOptions","COMPUTE_NORMALS","OPTIMIZE_NORMALS","IMPORT_VERTEX_COLORS","INVERT_Y","invertTextureY","UV_SCALING","materialLoadingFailsSilently","MATERIAL_LOADING_FAILS_SILENTLY","OPTIMIZE_WITH_UV","skipMaterials","SKIP_MATERIALS","USE_LEGACY_BEHAVIOR","_loadMTL","onSuccess","onFailure","pathOfFile","Tools","LoadFile","request","exception","createPlugin","canDirectLoad","importMeshAsync","_parseSolid","then","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","spriteManagers","loadAsync","loadAssetContainerAsync","container","AssetContainer","getActiveTextures","t","textures","catch","ex","fileToLoad","materialsFromMTLFile","fileName","mtlPromises","Promise","resolve","reject","dataLoaded","n","startIndex","_indices","dispose","getTotalIndices","Warn","all","isLine","Boolean","mat","getBindedMeshes","filter","clone","wireframe","RegisterSceneLoaderPlugin","globalObject","BABYLON"],"sourceRoot":""}